<html><head><base href="." />
    <title>very hard roblox aim training game</title>
    <style>
        body { margin: 0; overflow: hidden; cursor: none; }
        /* Update all UI elements to Roblox style */
        #info {
            display: none;
        }
    
        #healthContainer {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px; /* Updated width */
            height: 20px; /* Updated height */
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            display: flex;
            align-items: center;
        }
    
        #healthBar {
            height: 100%;
            background: linear-gradient(to right, #ff3333, #ff6666);
            transition: width 0.2s;
            border-radius: 8px;
        }
    
        #healthNumber {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
    
        #staminaContainer {
            position: fixed;
            left: 20px;
            bottom: 50px;
            width: 200px; /* Updated width */
            height: 20px; /* Updated height */
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            overflow: hidden;
        }
    
        .staminaSection {
            height: 100%;
            width: 33.33%;
            border-right: 2px solid rgba(255, 255, 255, 0.1);
        }
    
        .staminaSection:last-child {
            border-right: none;
        }
    
        .staminaSection.filled {
            background: linear-gradient(to right, #3399ff, #66b3ff);
        }
    
        /* Existing styles */
        .laser {
            position: absolute;
            width: 4px;
            height: 20px;
            background: #00f8ff;
            border-radius: 2px;
            box-shadow: 0 0 10px #00f8ff;
            pointer-events: none;
            transform-origin: center;
        }
    
        /* Add charge indicator styles */
        #chargeIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #00f8ff;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
            pointer-events: none;
            opacity: 0;
            box-shadow: 0 0 5px #00f8ff;
            z-index: 999;
        }
    
        #chargeIndicator.charging {
            opacity: 1;
        }
    
        /* Add health bar styles */
        #healthContainer {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px; /* Updated width */
            height: 20px; /* Updated height */
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex; /* Add flex display */
            align-items: center; /* Center items vertically */
        }
    
        #healthBar {
            height: 100%;
            background: linear-gradient(to right, #ff3333, #ff6666);
            transition: width 0.2s;
            border-radius: 8px;
        }
    
        #healthNumber {
            position: absolute;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
    
        /* Add particle styles */
        .bloodParticle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff0000;
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.3s;
        }
    
        /* Add key indicator styles */
        .key-indicator {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 8px 12px;
            font-family: 'Arial', sans-serif;
            font-size: 12px;
        }
    
        .key {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            padding: 4px 8px;
            margin-right: 8px;
            font-weight: bold;
        }
    
        #gameOverScreen {
            background: rgba(0, 0, 0, 0.85) !important;
            border-radius: 15px !important;
            border: 3px solid rgba(255, 255, 255, 0.2) !important;
            padding: 30px !important;
            text-align: center !important;
        }
    
        #gameOverScreen span {
            display: inline-block;
            margin-top: 15px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
    
        #gameOverScreen span:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
        }
    
        #killCounter {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            color: white;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
    
        #dash-indicator { display: none; }
        #slide-indicator { display: none; }
        #turn-indicator { display: none; }
        #punch-indicator { display: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    </head>
    <body>
    <div id="healthContainer">
        <div id="healthBar"></div>
        <div id="healthNumber">100</div> <!-- Added health number -->
    </div>
    
    <div id="staminaContainer">
        <div class="staminaSection filled" id="stamina1"></div>
        <div class="staminaSection filled" id="stamina2"></div>
        <div class="staminaSection filled" id="stamina3"></div>
    </div>
    
    <div id="chargeIndicator"></div>
    <div id="crosshair"></div>
    <div id="killCounter">Kills: 0</div>
    
    <script>
    // Add game over state variable and function after health variables
    let isGameOver = false;
    let killCount = 0; // Add kill count
    let straferExists = false;  // Track if a red enemy exists
    
    const EnemyType = {
        NORMAL: 'normal',
        LEAPER: 'leaper',
        STRAFER: 'strafer'  // New enemy type
    };
    
    // Update enemy spawn interval from 3000 to 2000 milliseconds
    const enemySpawnInterval = 2000; // Changed from 3000 to 2000 - now spawns every 2 seconds
    
    function gameOver() {
        isGameOver = true;
        // Lock player movement
        moveForward = false;
        moveBackward = false;
        moveLeft = false;
        moveRight = false;
        isDashing = false;
        isSliding = false;
        
        // Add game over UI with a specific ID
        const gameOverDiv = document.createElement('div');
        gameOverDiv.id = 'gameOverScreen'; // Add specific ID
        gameOverDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85) !important;
            color: #ff0000;
            padding: 30px;
            border-radius: 15px !important;
            border: 3px solid rgba(255, 255, 255, 0.2) !important;
            font-family: Arial, sans-serif;
            font-size: 32px;
            text-align: center;
            z-index: 1000;
        `;
        gameOverDiv.innerHTML = `
            GAME OVER<br>
            <span style="font-size: 16px; color: white;">Click to restart</span>
        `;
        document.body.appendChild(gameOverDiv);
        
        // Add click listener to restart
        document.addEventListener('click', restartGame);
    }
    
    function restartGame() {
        if (!isGameOver) return;
        
        // Reset game state
        isGameOver = false;
        playerHealth = 100;
        killCount = 0; // Reset kill count
        straferExists = false; // Add this line
        updateHealthUI();
        updateKillCounter(); // Update kill counter display
        
        // Clear enemies
        enemies.forEach(enemy => scene.remove(enemy.mesh));
        enemies.length = 0;
        
        // Reset player position
        camera.position.set(0, 2, 0);
        
        // Remove game over UI using ID
        const gameOverDiv = document.getElementById('gameOverScreen');
        if (gameOverDiv) {
            gameOverDiv.remove();
        }
        
        // Remove click listener
        document.removeEventListener('click', restartGame);
    }
    
    // Initialize Three.js scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    // Create checkerboard ground texture
    const groundSize = 100;
    const segments = 100;
    const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, segments, segments);
    const textureSize = segments;
    const data = new Uint8Array(textureSize * textureSize * 4);
    for (let i = 0; i < textureSize; i++) {
        for (let j = 0; j < textureSize; j++) {
            const isEven = (i + j) % 2 === 0;
            const color = isEven ? 80 : 50; // Grey and dark grey
            const index = (i * textureSize + j) * 4;
            data[index] = color;
            data[index + 1] = color;
            data[index + 2] = color;
            data[index + 3] = 255;
        }
    }
    const texture = new THREE.DataTexture(data, textureSize, textureSize);
    texture.needsUpdate = true;
    
    const groundMaterial = new THREE.MeshBasicMaterial({ 
        map: texture,
        side: THREE.DoubleSide
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = Math.PI / 2;
    scene.add(ground);
    
    // Create block-based gun model
    const gunGroup = new THREE.Group();
    
    // Main body
    const bodyGeometry = new THREE.BoxGeometry(0.3, 0.2, 1);
    const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
    const gunBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
    
    // Handle
    const handleGeometry = new THREE.BoxGeometry(0.15, 0.4, 0.2);
    const handleMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
    const gunHandle = new THREE.Mesh(handleGeometry, handleMaterial);
    gunHandle.position.y = -0.2;
    gunHandle.position.z = 0.2;
    
    // Barrel
    const barrelGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.4);
    const barrelMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
    const gunBarrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
    gunBarrel.position.z = 0.6;
    
    // Sight
    const sightGeometry = new THREE.BoxGeometry(0.05, 0.1, 0.1);
    const sightMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
    const gunSight = new THREE.Mesh(sightGeometry, sightMaterial);
    gunSight.position.y = 0.15;
    gunSight.position.z = 0.2;
    
    // Add all parts to gun group
    gunGroup.add(gunBody);
    gunGroup.add(gunHandle);
    gunGroup.add(gunBarrel);
    gunGroup.add(gunSight);
    
    // Initial position
    gunGroup.position.set(0.4, -0.3, -0.8);
    camera.add(gunGroup);
    
    // Enemy and projectile variables
    const enemies = [];
    const enemyProjectiles = [];
    const enemyProjectileSpeed = 0.3; // Changed from 0.8 to 0.3
    const enemyProjectileLifetime = 3000;
    const enemyFireRate = 2000; // Fire every 2 seconds
    const enemyCount = 1; // Initialize with just one enemy
    
    // Health system initialization
    let playerHealth = 100;
    const projectileDamage = 25;
    
    // Add blood particle variables
    const bloodParticles = [];
    const particleLifetime = 3000;
    const particlesPerEnemy = 15;
    const healingPerParticle = 5;
    const particleCollectDistance = 1.5;
    const particleSpeed = 0.1;
    
    // Add spawn timer and function near the enemy variables
    let lastEnemySpawnTime = Date.now();
    const maxEnemies = 10; // Optional cap on total enemies
    
    // Enemy class
    class Enemy {
        constructor(type = EnemyType.NORMAL) {
            // Create a group for the Roblox character
            this.mesh = new THREE.Group();
            
            // Store enemy type
            this.type = type;
    
            // Set properties based on type
            if (type === EnemyType.STRAFER) {
                this.health = 1.0;
                this.strafeAngle = Math.random() * Math.PI * 2;
                this.strafeRadius = 8;
                this.strafeSpeed = 0.05;
                this.lastFireTime = Date.now(); // Initialize lastFireTime
            } else {
                this.health = type === EnemyType.LEAPER ? 0.5 : 1.5;
            }
            
            // Body (torso)
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.8, 0.3),
                new THREE.MeshBasicMaterial({ 
                    color: type === EnemyType.LEAPER ? 0x008800 : (type === EnemyType.STRAFER ? 0xff0000 : 0x8844aa) 
                })
            );
            this.mesh.add(body);
    
            // Head
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.4, 0.4),
                new THREE.MeshBasicMaterial({ 
                    color: type === EnemyType.LEAPER ? 0x00aa00 : (type === EnemyType.STRAFER ? 0xff3333 : 0x9955bb) 
                })
            );
            head.position.y = 0.6;
            this.mesh.add(head);
    
            // Left arm
            const leftArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.6, 0.2),
                new THREE.MeshBasicMaterial({ 
                    color: type === EnemyType.LEAPER ? 0x006600 : (type === EnemyType.STRAFER ? 0xcc0000 : 0x773399) 
                })
            );
            leftArm.position.set(-0.4, 0.1, 0);
            this.mesh.add(leftArm);
    
            // Right arm
            const rightArm = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.6, 0.2),
                new THREE.MeshBasicMaterial({ 
                    color: type === EnemyType.LEAPER ? 0x006600 : (type === EnemyType.STRAFER ? 0xcc0000 : 0x773399) 
                })
            );
            rightArm.position.set(0.4, 0.1, 0);
            this.mesh.add(rightArm);
    
            // Left leg
            const leftLeg = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.6, 0.2),
                new THREE.MeshBasicMaterial({ 
                    color: type === EnemyType.LEAPER ? 0x004400 : (type === EnemyType.STRAFER ? 0xaa0000 : 0x662288) 
                })
            );
            leftLeg.position.set(-0.2, -0.7, 0);
            this.mesh.add(leftLeg);
    
            // Right leg
            const rightLeg = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.6, 0.2),
                new THREE.MeshBasicMaterial({ 
                    color: type === EnemyType.LEAPER ? 0x004400 : (type === EnemyType.STRAFER ? 0xaa0000 : 0x662288) 
                })
            );
            rightLeg.position.set(0.2, -0.7, 0);
            this.mesh.add(rightLeg);
    
            // Position and properties
    
            // Random position around player
            if (type !== EnemyType.STRAFER) { // Only set specific position if not strafe
                const angle = Math.random() * Math.PI * 2;
                const distance = 15 + Math.random() * 10; // Between 15-25 units away
                this.mesh.position.x = Math.cos(angle) * distance;
                this.mesh.position.z = Math.sin(angle) * distance;
                this.mesh.position.y = 1.5;
            } else {
                this.mesh.position.y = 1.5; // Default height for strafe enemies
            }
            
            this.lastFireTime = 0;
        }
    
        takeDamage(amount) {
            this.health = Math.max(0, this.health - amount); // Prevent negative health
    
            // Flash all parts red when hit
            this.mesh.children.forEach(part => {
                part.material.color.setHex(0xff0000);
            });
    
            setTimeout(() => {
                if (this.health > 0) {
                    this.mesh.children.forEach(part => {
                        if (this.type === EnemyType.LEAPER) {
                            part.material.color.setHex(0x008800);
                        } else if (this.type === EnemyType.STRAFER) {
                            part.material.color.setHex(0xff0000);
                        } else {
                            part.material.color.setHex(0x8844aa);
                        }
                    });
                }
            }, 100);
    
            if (this.health <= 0) {
                // Increment kill count
                killCount++;
                updateKillCounter();
    
                // Track when a red enemy dies
                if (this.type === EnemyType.STRAFER) {
                    straferExists = false;
                }
    
                // Create blood particles before removing enemy
                createBloodParticles(this.mesh.position);
                
                // Ensure enemy is removed from both scene and array
                const index = enemies.indexOf(this);
                if (index > -1) {
                    enemies.splice(index, 1);
                    scene.remove(this.mesh);
                }
            }
        }
    
        fire(playerPosition) {
            const projectileGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({ 
                color: this.type === EnemyType.STRAFER ? 0xff0000 : 0xff0000,
                transparent: true,
                opacity: 0.8
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            
            projectile.position.copy(this.mesh.position);
            
            // Base projectile damage
            projectile.damage = 1;
            
            // Calculate direction to player
            const direction = new THREE.Vector3()
                .subVectors(playerPosition, this.mesh.position)
                .normalize();
                
            projectile.velocity = direction.multiplyScalar(enemyProjectileSpeed);
            
            scene.add(projectile);
            enemyProjectiles.push({
                mesh: projectile,
                created: Date.now()
            });
        }
    
        update(playerPosition) {
            if (this.type === EnemyType.STRAFER) {
                // Update strafe angle
                this.strafeAngle += this.strafeSpeed;
                
                // Calculate new position around player
                const newX = playerPosition.x + Math.cos(this.strafeAngle) * this.strafeRadius;
                const newZ = playerPosition.z + Math.sin(this.strafeAngle) * this.strafeRadius;
                
                // Smoothly move to new position
                this.mesh.position.x += (newX - this.mesh.position.x) * 0.1;
                this.mesh.position.z += (newZ - this.mesh.position.z) * 0.1;
                
                // Add jumping behavior
                if (!this.jumpVelocity) this.jumpVelocity = 0;
                if (!this.isJumping && Math.random() < 0.02) { // 2% chance to jump each frame
                    this.jumpVelocity = 0.2;
                    this.isJumping = true;
                }
                
                // Apply jump physics
                this.mesh.position.y += this.jumpVelocity;
                this.jumpVelocity -= 0.01; // gravity
                
                if (this.mesh.position.y <= 1.5) { // ground check
                    this.mesh.position.y = 1.5;
                    this.jumpVelocity = 0;
                    this.isJumping = false;
                }
                
                // Look at player
                this.mesh.lookAt(playerPosition);
                
                // Fire at player more frequently
                const now = Date.now();
                if (now - this.lastFireTime > enemyFireRate * 0.7) { // Fire 30% faster than normal enemies
                    this.fire(playerPosition);
                    this.lastFireTime = now;
                }
            } else if (this.type === EnemyType.NORMAL) {
                // Look at player
                this.mesh.lookAt(playerPosition);
                
                // Add jumping behavior for normal (purple) enemies
                if (!this.jumpVelocity) this.jumpVelocity = 0;
                if (!this.isJumping && Math.random() < 0.02) { // 2% chance to jump each frame
                    this.jumpVelocity = 0.2;
                    this.isJumping = true;
                }
                
                // Apply jump physics
                this.mesh.position.y += this.jumpVelocity;
                this.jumpVelocity -= 0.01; // gravity
                
                if (this.mesh.position.y <= 1.5) { // ground check
                    this.mesh.position.y = 1.5;
                    this.jumpVelocity = 0;
                    this.isJumping = false;
                }
                
                // Move towards player
                const direction = new THREE.Vector3()
                    .subVectors(playerPosition, this.mesh.position)
                    .normalize();
                this.mesh.position.add(direction.multiplyScalar(0.1));
                
                const now = Date.now();
                if (now - this.lastFireTime > enemyFireRate) {
                    this.fire(playerPosition);
                    this.lastFireTime = now;
                }
            } else if (this.type === EnemyType.LEAPER) {
                const distToPlayer = this.mesh.position.distanceTo(playerPosition);
                
                if (!this.isLeaping && !this.leapCooldown) {
                    // Reduce trigger distance from 5 to 3
                    if (distToPlayer < 3) {
                        if (!this.isPreparingLeap) {
                            // Start leap preparation
                            this.isPreparingLeap = true;
                            setTimeout(() => {
                                // Start actual leap after delay
                                this.isLeaping = true;
                                this.hasDealtDamage = false;
                                const direction = new THREE.Vector3()
                                    .subVectors(playerPosition, this.mesh.position)
                                    .normalize();
                                // Reduce leap velocity from 1 to 0.6
                                this.leapVelocity = direction.multiplyScalar(0.6);
                                this.isPreparingLeap = false;
                                
                                // Reset leap after 1 second
                                setTimeout(() => {
                                    this.isLeaping = false;
                                    this.leapCooldown = true;
                                    setTimeout(() => {
                                        this.leapCooldown = false;
                                    }, 2000);
                                }, 1000);
                            }, 500); // 500ms preparation pause
                        }
                        // Don't move while preparing to leap
                        if (this.isPreparingLeap) {
                            return;
                        }
                    } else {
                        // Chase player when not in leap range
                        const direction = new THREE.Vector3()
                            .subVectors(playerPosition, this.mesh.position)
                            .normalize();
                        this.mesh.position.add(direction.multiplyScalar(this.moveSpeed));
                    }
                } else if (this.isLeaping) {
                    // Apply leap movement
                    this.mesh.position.add(this.leapVelocity);
                    
                    // Only check for player collision during leap
                    if (this.isLeaping && !this.hasDealtDamage && this.mesh.position.distanceTo(playerPosition) < 2) {
                        damagePlayer(30);
                        this.hasDealtDamage = true;
                    }
                }
            }
        }
    }
    
    // Particle creation function
    function createBloodParticles(position) {
        for(let i = 0; i < particlesPerEnemy; i++) {
            const particle = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 4, 4),
                new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8
                })
            );
            
            // Random spread
            particle.position.copy(position);
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.3,
                Math.random() * 0.2,
                (Math.random() - 0.5) * 0.3
            );
            
            scene.add(particle);
            bloodParticles.push({
                mesh: particle,
                created: Date.now(),
                collected: false,
                touchedGround: false // Add this flag
            });
        }
    }
    
    // Initialize with just one enemy
    const enemy = new Enemy();
    enemies.push(enemy);
    scene.add(enemy.mesh);
    
    // Character controller setup
    camera.position.y = 2;
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let isJumping = false;
    let isSlaming = false; // New variable for ground slam
    let canDoubleJump = false; // Added for double jump
    let velocity = 0;
    const gravity = -0.015;
    const normalJumpPower = 0.3; // Rename existing jumpPower
    const boostedJumpPower = 0.45; // 50% stronger jump
    let canBoostJump = false; // New variable for tracking jump boost
    const slamVelocity = -0.5; // Fast downward velocity for slam
    
    // Dash mechanics
    let isDashing = false;
    let dashCooldown = false;
    const dashSpeed = 0.7; // Increased from 0.5 to 0.7
    const dashDuration = 200;
    const dashCooldownTime = 300;
    
    // Modified slide mechanics
    let isSliding = false;
    let slideDirection = new THREE.Vector3();
    const slideSpeed = 0.4;
    const normalCameraHeight = 2;
    const slideCameraHeight = 1;
    let currentCameraHeight = normalCameraHeight;
    const cameraHeightLerpSpeed = 0.1;
    const slideTurnSpeed = 0.03; // Speed at which the player can turn while sliding
    
    // Stamina system
    let currentStamina = 3;
    const maxStamina = 3;
    const staminaRegenerationTime = 1500; // milliseconds
    let isRegenerating = false;
    
    // Changed moveSpeed to be half of slideSpeed
    const moveSpeed = slideSpeed * 0.5; // This is now 0.2 since slideSpeed is 0.4
    
    // Add after other variable declarations
    let isPunching = false;
    const punchDuration = 200;
    
    // Laser variables
    const lasers = [];
    const laserSpeed = 2; // Doubled from 1
    const laserLifetime = 2000; // 2 seconds
    
    // Charge mechanics variables
    let isCharging = false;
    let chargeStartTime = 0;
    const minChargeTime = 500; // Time required for minimum charge
    const maxChargeTime = 1000; // Reduced from 2000 to 1000 - now takes 1 second to fully charge
    const minLaserSize = 0.1; // Original laser size
    const maxLaserSize = 0.3; // Max charged laser size
    const minLaserDamage = 1; // Changed from 20
    const maxLaserDamage = 1; // Changed from 60 - no more charge scaling
    
    // Add cooldown variables
    let canFire = true;
    const fireCooldown = 400; // 0.4 seconds in milliseconds
    
    function updateKillCounter() {
        document.getElementById('killCounter').textContent = `Kills: ${killCount}`;
    }
    
    function updateStaminaUI() {
        for(let i = 1; i <= maxStamina; i++) {
            const section = document.getElementById(`stamina${i}`);
            section.className = `staminaSection ${i <= currentStamina ? 'filled' : 'empty'}`;
        }
    }
    
    function regenerateStamina() {
        if(currentStamina < maxStamina && !isRegenerating) {
            isRegenerating = true;
            setTimeout(() => {
                currentStamina++;
                updateStaminaUI();
                isRegenerating = false;
                if(currentStamina < maxStamina) {
                    regenerateStamina();
                }
            }, staminaRegenerationTime);
        }
    }
    
    // Health UI update function
    function updateHealthUI() {
        const healthBar = document.getElementById('healthBar');
        const healthNumber = document.getElementById('healthNumber');
        healthBar.style.width = `${playerHealth}%`;
        healthNumber.textContent = Math.round(playerHealth); // Round to whole number
    }
    
    // Player damage function
    function damagePlayer(amount) {
        if (isGameOver) return;
        
        playerHealth = Math.max(0, playerHealth - amount);
        updateHealthUI();
        
        if (playerHealth <= 0) {
            gameOver();
        }
    }
    
    // Mouse look controls
    let pitch = 0;
    let yaw = 0;
    document.addEventListener('mousemove', (event) => {
        if(document.pointerLockElement === document.body) {
            yaw -= event.movementX * 0.002;
            pitch -= event.movementY * 0.002;
            pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        }
    });
    
    // Lock pointer on click
    renderer.domElement.addEventListener('click', () => {
        document.body.requestPointerLock();
    });
    
    // Movement controls
    document.addEventListener('keydown', (event) => {
        switch(event.code) {
            case 'KeyW': moveForward = true; break;
            case 'KeyS': moveBackward = true; break;
            case 'KeyA': moveLeft = true; break;
            case 'KeyD': moveRight = true; break;
            case 'Space': 
                if (!isJumping) {
                    velocity = canBoostJump ? boostedJumpPower : normalJumpPower;
                    isJumping = true;
                    canBoostJump = false;
                    canDoubleJump = true; // Enable double jump
                } else if (canDoubleJump) {
                    // Double jump triggers dash
                    velocity = normalJumpPower;
                    if (currentStamina > 0) {
                        isDashing = true;
                        currentStamina--;
                        updateStaminaUI();
                        regenerateStamina();
                        
                        setTimeout(() => {
                            isDashing = false;
                        }, dashDuration);
                    }
                    canDoubleJump = false; // Disable further double jumps
                }
                break;
            case 'KeyF':
                if (!isPunching) {
                    isPunching = true;
                    setTimeout(() => {
                        isPunching = false;
                    }, punchDuration);
                }
                break;
        }
    });
    
    // Replace existing mousedown listener with:
    document.addEventListener('mousedown', (event) => {
        if(document.pointerLockElement === document.body && event.button === 0 && canFire) {
            isCharging = true;
            chargeStartTime = Date.now();
            document.getElementById('chargeIndicator').classList.add('charging');
        }
    });
    
    // Add mouseup listener
    document.addEventListener('mouseup', (event) => {
        if(document.pointerLockElement === document.body && event.button === 0 && isCharging && canFire) {
            const chargeTime = Math.min(Date.now() - chargeStartTime, maxChargeTime);
            const chargeRatio = (chargeTime - minChargeTime) / (maxChargeTime - minChargeTime);
            const laserSize = minLaserSize + (maxLaserSize - minLaserSize) * Math.max(0, chargeRatio);
            const laserDamage = minLaserDamage + (maxLaserDamage - minLaserDamage) * Math.max(0, chargeRatio);
            
            // Fire multiple shots if fully charged
            const numShots = chargeRatio >= 1 ? 3 : 1;
            let shotsFired = 0;
            
            const fireShot = () => {
                const laser = new THREE.Mesh(
                    new THREE.BoxGeometry(laserSize, laserSize, 3),
                    new THREE.MeshBasicMaterial({
                        color: 0x00f8ff,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                laser.position.copy(camera.position);
                laser.quaternion.copy(camera.quaternion);
                laser.velocity = forward.multiplyScalar(laserSpeed);
                laser.damage = laserDamage;
                
                scene.add(laser);
                lasers.push({
                    mesh: laser,
                    created: Date.now()
                });
    
                shotsFired++;
                if (shotsFired < numShots) {
                    setTimeout(fireShot, 100); // Fire next shot after 100ms
                }
            };
    
            fireShot();
            
            // Visual feedback removed for weapon overlay
            // Reset charging
            isCharging = false;
            document.getElementById('chargeIndicator').classList.remove('charging');
    
            // Implement cooldown
            canFire = false;
            setTimeout(() => {
                canFire = true;
            }, fireCooldown);
        }
    });
    
    document.addEventListener('keyup', (event) => {
        switch(event.code) {
            case 'KeyW': moveForward = false; break;
            case 'KeyS': moveBackward = false; break;
            case 'KeyA': moveLeft = false; break;
            case 'KeyD': moveRight = false; break;
            case 'KeyC': 
                isSliding = false; 
                break;
        }
    });
    
    // Camera shake parameters
    let shakeTime = 0;
    const shakeSpeed = 0.01;
    const shakeAmount = 0.03;
    const shakeFrequency = 2;
    
    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        
        if (isGameOver) {
            renderer.render(scene, camera);
            return;
        }
        
        // Update camera rotation
        camera.rotation.order = 'YXZ';
        
        // Gun movement animation
        if (gunGroup) {
            // Add slight bob/sway based on movement
            const t = Date.now() * 0.002;
            const bobHeight = Math.sin(t * 2) * 0.01;
            const swayAngle = Math.sin(t) * 0.02;
            
            gunGroup.position.y = -0.3 + bobHeight;
            gunGroup.rotation.z = swayAngle;
            
            // Adjust position while sliding
            if (isSliding) {
                gunGroup.position.y = -0.2;
                gunGroup.rotation.x = 0.2;
            } else {
                gunGroup.rotation.x = 0;
            }
        }
    
        // Check if it's time to spawn a new enemy
        const now = Date.now(); // Already exists in code
        if (now - lastEnemySpawnTime > enemySpawnInterval && enemies.length < maxEnemies) {
            const rand = Math.random();
            let type;
            
            // Check if we should spawn a red enemy
            if (!straferExists) {
                type = EnemyType.STRAFER;
                straferExists = true;
            } else {
                // Only spawn purple or green if no red should be spawned
                if (rand < 0.8) {
                    type = EnemyType.NORMAL; // Purple ones - 80% chance
                } else {
                    type = EnemyType.LEAPER; // Green ones - 20% chance
                }
            }
            
            const enemy = new Enemy(type);
            enemies.push(enemy);
            scene.add(enemy.mesh);
            lastEnemySpawnTime = now;
        }
    
        // Update and collect blood particles
        for(let i = bloodParticles.length - 1; i >= 0; i--) {
            const particle = bloodParticles[i];
            
            if (!particle.collected) {
                // Apply gravity and update position
                particle.mesh.velocity.y -= 0.01;
                particle.mesh.position.add(particle.mesh.velocity);
                
                // Check ground collision
                if (particle.mesh.position.y < 0.1) {
                    particle.mesh.position.y = 0.1;
                    particle.touchedGround = true; // Set ground contact flag
                    
                    // Start fade out
                    particle.mesh.material.opacity -= 0.1;
                    if (particle.mesh.material.opacity <= 0) {
                        scene.remove(particle.mesh);
                        bloodParticles.splice(i, 1);
                        continue;
                    }
                }
                
                // Check collection by player
                const distanceToPlayer = particle.mesh.position.distanceTo(camera.position);
                if (distanceToPlayer < particleCollectDistance) {
                    particle.collected = true;
                    // Heal player
                    playerHealth = Math.min(100, playerHealth + healingPerParticle);
                    updateHealthUI();
                    
                    // Fade out effect
                    particle.mesh.material.opacity = 0;
                    setTimeout(() => {
                        scene.remove(particle.mesh);
                        bloodParticles.splice(i, 1);
                    }, 300);
                }
            }
            
            // Remove old particles
            if(now - particle.created > particleLifetime) {
                scene.remove(particle.mesh);
                bloodParticles.splice(i, 1);
            }
        }
    
        // Apply camera shake while sliding
        if (isSliding) {
            shakeTime += shakeSpeed;
            const shakeOffsetX = Math.sin(shakeTime * shakeFrequency) * shakeAmount;
            const shakeOffsetY = Math.cos(shakeTime * shakeFrequency) * shakeAmount;
            camera.rotation.x = pitch + shakeOffsetY;
            camera.rotation.z = shakeOffsetX;  // Roll effect
        } else {
            camera.rotation.x = pitch;
            camera.rotation.z = 0;  // Reset roll when not sliding
        }
        
        camera.rotation.y = yaw;
    
        // Update enemies
        enemies.forEach(enemy => {
            enemy.update(camera.position);
        });
        
        // Update enemy projectiles
        const nowProjectiles = Date.now();
        for(let i = enemyProjectiles.length - 1; i >= 0; i--) {
            const projectile = enemyProjectiles[i];
            projectile.mesh.position.add(projectile.mesh.velocity);
            
            // Check for projectile hits on player
            const distanceToPlayer = projectile.mesh.position.distanceTo(camera.position);
            if (distanceToPlayer < 1) {
                // Remove projectile and damage player
                scene.remove(projectile.mesh);
                enemyProjectiles.splice(i, 1);
                if (!projectile.mesh.parried) { // Only take damage if not parried
                    damagePlayer(projectileDamage);
                }
            }
    
            // Remove old projectiles
            if(nowProjectiles - projectile.created > enemyProjectileLifetime) {
                scene.remove(projectile.mesh);
                enemyProjectiles.splice(i, 1);
            }
        }
    
        // Check parried projectile hits on enemies
        for(let i = enemyProjectiles.length - 1; i >= 0; i--) {
            const projectile = enemyProjectiles[i];
            if (projectile.mesh.parried) { // Only check parried projectiles
                for(let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const distance = projectile.mesh.position.distanceTo(enemy.mesh.position);
                    if (distance < 1.5) { // Using same hit radius as lasers
                        enemy.takeDamage(projectile.mesh.damage); // Use the projectile's damage value
                        scene.remove(projectile.mesh);
                        enemyProjectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }
    
        // Check laser hits
        for(let i = lasers.length - 1; i >= 0; i--) {
            const laser = lasers[i];
            for(let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                const distance = laser.mesh.position.distanceTo(enemy.mesh.position);
                if (distance < 1.5) { // Increased hit detection radius slightly
                    enemy.takeDamage(laser.mesh.damage);
                    scene.remove(laser.mesh);
                    lasers.splice(i, 1);
                    break; // Exit inner loop once hit is detected
                }
            }
        }
    
        // Check punch hits
        if (isPunching) {
            const punchRange = 3;
            const punchDamage = 1; // Changed from 100
            const punchPosition = camera.position.clone();
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            punchPosition.add(forward.multiplyScalar(2));
            
            // Check enemy hits
            for(let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const distance = enemy.mesh.position.distanceTo(punchPosition);
                if (distance < punchRange) {
                    enemy.takeDamage(punchDamage);
                }
            }
    
            // Check projectile hits during punch
            for(let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const projectile = enemyProjectiles[i];
                const distance = projectile.mesh.position.distanceTo(punchPosition);
                if (distance < punchRange) {
                    // Get the direction player is looking
                    const forward = new THREE.Vector3();
                    camera.getWorldDirection(forward);
                    
                    // Set projectile velocity in look direction
                    projectile.mesh.velocity = forward.multiplyScalar(enemyProjectileSpeed * 1.5); // 1.5x speed when parried
                    projectile.mesh.damage = 1.5; // Parried projectile damage
                    projectile.mesh.parried = true; // Mark as parried
                    projectile.mesh.material.color.setHex(0x00ff00); // Visual feedback
                }
            }
        }
    
        // Update lasers
        for(let i = lasers.length - 1; i >= 0; i--) {
            const laser = lasers[i];
            laser.mesh.position.add(laser.mesh.velocity);
            
            // Remove old lasers
            if(now - laser.created > laserLifetime) {
                scene.remove(laser.mesh);
                lasers.splice(i, 1);
            }
        }
    
        // Update movement
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        
        const right = new THREE.Vector3();
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
    
        if (isSliding) {
            // Allow turning while sliding using A and D
            if(moveLeft) {
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(slideTurnSpeed);
                slideDirection.applyMatrix4(rotationMatrix);
            }
            if(moveRight) {
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.makeRotationY(-slideTurnSpeed);
                slideDirection.applyMatrix4(rotationMatrix);
            }
            
            // Move in the stored slide direction
            camera.position.addScaledVector(slideDirection, slideSpeed);
        } else {
            const currentSpeed = isDashing ? dashSpeed : moveSpeed;
    
            if(moveForward) camera.position.addScaledVector(forward, currentSpeed);
            if(moveBackward) camera.position.addScaledVector(forward, -currentSpeed);
            if(moveLeft) camera.position.addScaledVector(right, -currentSpeed);
            if(moveRight) camera.position.addScaledVector(right, currentSpeed);
        }
    
        if (isJumping) {
            camera.position.y += velocity;
            velocity += gravity;
            
            if (camera.position.y <= currentCameraHeight) {
                camera.position.y = currentCameraHeight;
                velocity = 0;
                isJumping = false;
                if (isSlaming) {
                    isSlaming = false;
                    canBoostJump = true;
                
                }
            }
        } else {
            camera.position.y = currentCameraHeight;
        }
    
      const targetHeight = isSliding ? slideCameraHeight : normalCameraHeight;
        currentCameraHeight += (targetHeight - currentCameraHeight) * cameraHeightLerpSpeed;

        if(isCharging) {
            const chargeTime = Date.now() - chargeStartTime;
            const chargeRatio = Math.min((chargeTime - minChargeTime) / (maxChargeTime - minChargeTime), 1);
            const indicator = document.getElementById('chargeIndicator');
            const size = 4 + (chargeRatio * 12);
            indicator.style.width = `${size}px`;
            indicator.style.height = `${size}px`;
            indicator.style.boxShadow = `0 0 ${5 + (chargeRatio * 15)}px #00f8ff`;
        }
    
        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    animate();
    </script>
    </body>
    </html>
